name: StockWiz CI/CD Pipeline - DEV y TEST

on:
  push:
    branches: ["develop"]

jobs:
  # JOB 1: VALIDACIÓN y DESPLIEGUE a DEV
  deploy_dev:
    runs-on: ubuntu-latest
    steps:

      # CHECKOUT

      - name: Checkout Code
        uses: actions/checkout@v4

      # AWS CREDENTIALS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      # TERRAFORM INIT & SETUP
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform init - DEV
        working-directory: ./infra
        run: |
          # Configuración del backend para el estado 'dev'
          terraform init -reconfigure \
            -backend-config="bucket=stockwiz-tfstate" \
            -backend-config="key=dev/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="encrypt=true"


      # QUALITY GATE: ANÁLISIS ESTÁTICO CON FLAKE8 
      
      - name: Ejecutar Flake8 y Generar Reporte
        id: flake8_check
        working-directory: ./product-service 
        run: |
          echo "Iniciando análisis estático del product-service y generando reporte..."
          pip install -r requirements.txt
          pip install flake8
          
          # CRÍTICO: Redirigir la salida (errores y advertencias) a un archivo
          flake8 main.py > flake8_report.txt 2>&1
          
          # Verificar el código de salida ($?)
          if [ $? -ne 0 ]; then
            echo "Advertencia: Flake8 encontró fallos. El reporte ha sido guardado."
            echo "::set-output name=quality_status::FAIL_SILENT"
          else
            echo "Análisis estático con Flake8 completado sin fallos."
            echo "::set-output name=quality_status::PASS"
          fi

      # TERRAFORM APPLY #1 — CREAR ECR + VPC + ALB + ECS vacío

      - name: Terraform apply - DEV (Infra Base)
        working-directory: ./infra
        run: "terraform apply -auto-approve -var-file=\"env/dev.tfvars\" -var=\"db_password_secret=${{ secrets.DB_PASSWORD_DEV }}\" -var=\"inventory_api_key_secret=${{ secrets.INVENTORY_KEY_DEV }}\""
        
      # LOGIN ECR

      - name: Login ECR
        id: ecr_dev
        uses: aws-actions/amazon-ecr-login@v2

      # BUILD & PUSH FULLSTACK IMAGE

      - name: Build & push fullstack container
        run: |
          REG="${{ steps.ecr_dev.outputs.registry }}"
          # Asumiendo que el Dockerfile está en la raíz
          docker build -t $REG/stockwiz-dev/fullstack:dev-latest .
          docker push $REG/stockwiz-dev/fullstack:dev-latest
          
      # TERRAFORM APPLY #2 — CREAR TASK DEFINITION CON LA IMAGEN

      - name: Terraform apply - DEV (Imagen Final)
        id: apply_dev_image
        working-directory: ./infra
        run: "terraform apply -auto-approve -var-file=\"env/dev.tfvars\" -var=\"full_image=${{ steps.ecr_dev.outputs.registry }}/stockwiz-dev/fullstack:dev-latest\" -var=\"db_password_secret=${{ secrets.DB_PASSWORD_DEV }}\" -var=\"inventory_api_key_secret=${{ secrets.INVENTORY_KEY_DEV }}\""
      
      # UPDATE ECS SERVICE
      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster stockwiz-dev-cluster \
            --service stockwiz-dev-svc \
            --force-new-deployment

      # OBLIGATORIO: OBTENER EL DNS DEL ALB PARA EL JOB SIGUIENTE
      - name: Get ALB DNS Name - DEV
        id: get_dev_url
        working-directory: ./infra
        run: echo "dev_alb_url=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
        
    outputs:
      dev_alb_url: ${{ steps.get_dev_url.outputs.dev_alb_url }}

  # ----------------------------------------------------
  # JOB 2: DESPLIEGUE a TEST y PRUEBAS FUNCIONALES
  # ----------------------------------------------------
  test_functional:
    name: Run Functional Tests (TEST Env)
    runs-on: ubuntu-latest
    needs: deploy_dev
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 1. Configuración AWS y Terraform (Mismo setup que DEV)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # 2. Despliegue de Infraestructura TEST
      - name: Terraform init - TEST
        working-directory: ./infra
        run: |
          # Usamos el backend configurado para TEST (key diferente)
          terraform init -reconfigure \
            -backend-config="bucket=stockwiz-tfstate" \
            -backend-config="key=test/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="encrypt=true"

      - name: Terraform apply - TEST (Despliegue Temporal)
        id: deploy_test
        working-directory: ./infra
        run: |
          # Usa la imagen construida en el job anterior y variables de TEST
          terraform apply -auto-approve -var-file=\"env/test.tfvars\" -var=\"full_image=${{ needs.deploy_dev.outputs.ecr_dev.outputs.registry }}/stockwiz-dev/fullstack:dev-latest\" -var=\"db_password_secret=${{ secrets.DB_PASSWORD_TEST }}\" -var=\"inventory_api_key_secret=${{ secrets.INVENTORY_KEY_TEST }}\"

      # 3. Obtener la URL del ALB de TEST
      - name: Get ALB DNS Name - TEST
        id: get_test_url
        working-directory: ./infra
        run: |
          TEST_ALB_URL=$(terraform output -raw alb_dns_name)
          echo "test_alb_url=$TEST_ALB_URL" >> $GITHUB_ENV
        
      # 4. Ejecución de Pruebas Funcionales (Newman)
      - name: Ejecutar Pruebas Funcionales (Newman)
        env:
          TEST_BASE_URL: ${{ env.test_alb_url }} 
        working-directory: ./tests
        run: |
          echo "Iniciando pruebas Newman..."
          
          # 1. Instalar Newman y el reporter de JUnit
          npm install -g newman
          npm install -g newman-reporter-junitfull
          
          # 2. Ejecutar y guardar el reporte en un archivo .xml
          newman run stockwiz_api_collection.json \
            --global-var "baseUrl=${{ env.TEST_BASE_URL }}" \
            --reporter junitfull --reporter-junit-export results/newman_report.xml
          
          echo "Reporte JUnit generado en tests/results/newman_report.xml"
      - name: Subir Reporte Newman como Artifact
        uses: actions/upload-artifact@v4
        with:
          name: reporte-pruebas-funcionales-${{ github.sha }}
          path: tests/results/newman_report.xml
          
      # 5. Cleanup (Destruir el ambiente de TEST)
      - name: Destruir Infraestructura TEST
        if: always() # Ejecutar siempre, incluso si las pruebas fallaron
        working-directory: ./infra
        run: |
          echo "Destruyendo ambiente TEST después de la ejecución de pruebas..."
          terraform destroy -var-file=\"env/test.tfvars\" -auto-approve
